{"version":3,"file":"glTFExporter.js","sourceRoot":"","sources":["../../../../sourceES6/serializers/src/glTF/2.0/glTFExporter.ts"],"names":[],"mappings":"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","sourcesContent":["import { AccessorType, IBufferView, IAccessor, INode, IScene, IMesh, IMaterial, ITexture, IImage, ISampler, IAnimation, ImageMimeType, IMeshPrimitive, IBuffer, IGLTF, MeshPrimitiveMode, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\n\r\nimport { FloatArray, Nullable, IndicesArray } from \"@babylonjs/core/types\";\r\nimport { Viewport, Color3, Vector2, Vector3, Vector4, Quaternion } from \"@babylonjs/core/Maths/math\";\r\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { Node } from \"@babylonjs/core/node\";\r\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { LinesMesh } from \"@babylonjs/core/Meshes/linesMesh\";\r\nimport { InstancedMesh } from \"@babylonjs/core/Meshes/instancedMesh\";\r\nimport { BaseTexture } from \"@babylonjs/core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\nimport { Material } from \"@babylonjs/core/Materials/material\";\r\nimport { MultiMaterial } from \"@babylonjs/core/Materials/multiMaterial\";\r\nimport { Engine } from \"@babylonjs/core/Engines/engine\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\n\r\nimport { IGLTFExporterExtensionV2 } from \"./glTFExporterExtension\";\r\nimport { _GLTFMaterialExporter } from \"./glTFMaterialExporter\";\r\nimport { IExportOptions } from \"./glTFSerializer\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport { _GLTFAnimation } from \"./glTFAnimation\";\r\n\r\n/**\r\n * Utility interface for storing vertex attribute data\r\n * @hidden\r\n */\r\ninterface _IVertexAttributeData {\r\n    /**\r\n     * Specifies the Babylon Vertex Buffer Type (Position, Normal, Color, etc.)\r\n    */\r\n    kind: string;\r\n\r\n    /**\r\n     * Specifies the glTF Accessor Type (VEC2, VEC3, etc.)\r\n    */\r\n    accessorType: AccessorType;\r\n\r\n    /**\r\n     * Specifies the BufferView index for the vertex attribute data\r\n    */\r\n    bufferViewIndex?: number;\r\n\r\n    byteStride?: number;\r\n}\r\n/**\r\n * Converts Babylon Scene into glTF 2.0.\r\n * @hidden\r\n */\r\nexport class _Exporter {\r\n    /**\r\n     * Stores the glTF to export\r\n     */\r\n    public _glTF: IGLTF;\r\n    /**\r\n     * Stores all generated buffer views, which represents views into the main glTF buffer data\r\n     */\r\n    public _bufferViews: IBufferView[];\r\n    /**\r\n     * Stores all the generated accessors, which is used for accessing the data within the buffer views in glTF\r\n     */\r\n    public _accessors: IAccessor[];\r\n    /**\r\n     * Stores all the generated nodes, which contains transform and/or mesh information per node\r\n     */\r\n    private _nodes: INode[];\r\n    /**\r\n     * Stores all the generated glTF scenes, which stores multiple node hierarchies\r\n     */\r\n    private _scenes: IScene[];\r\n    /**\r\n     * Stores all the generated mesh information, each containing a set of primitives to render in glTF\r\n     */\r\n    private _meshes: IMesh[];\r\n    /**\r\n     * Stores all the generated material information, which represents the appearance of each primitive\r\n     */\r\n    public _materials: IMaterial[];\r\n\r\n    public _materialMap: { [materialID: number]: number };\r\n    /**\r\n     * Stores all the generated texture information, which is referenced by glTF materials\r\n     */\r\n    public _textures: ITexture[];\r\n    /**\r\n     * Stores all the generated image information, which is referenced by glTF textures\r\n     */\r\n    public _images: IImage[];\r\n\r\n    /**\r\n     * Stores all the texture samplers\r\n     */\r\n    public _samplers: ISampler[];\r\n    /**\r\n     * Stores all the generated animation samplers, which is referenced by glTF animations\r\n     */\r\n    /**\r\n     * Stores the animations for glTF models\r\n     */\r\n    private _animations: IAnimation[];\r\n    /**\r\n     * Stores the total amount of bytes stored in the glTF buffer\r\n     */\r\n    private _totalByteLength: number;\r\n    /**\r\n     * Stores a reference to the Babylon scene containing the source geometry and material information\r\n     */\r\n    public _babylonScene: Scene;\r\n    /**\r\n     * Stores a map of the image data, where the key is the file name and the value\r\n     * is the image data\r\n     */\r\n    public _imageData: { [fileName: string]: { data: Uint8Array, mimeType: ImageMimeType } };\r\n\r\n    /**\r\n     * Stores a map of the unique id of a node to its index in the node array\r\n     */\r\n    private _nodeMap: { [key: number]: number };\r\n\r\n    /**\r\n     * Specifies if the Babylon scene should be converted to right-handed on export\r\n     */\r\n    public _convertToRightHandedSystem: boolean;\r\n\r\n    /**\r\n     * Baked animation sample rate\r\n     */\r\n    private _animationSampleRate: number;\r\n\r\n    /**\r\n     * Callback which specifies if a node should be exported or not\r\n     */\r\n    private _shouldExportNode: ((babylonNode: Node) => boolean);\r\n\r\n    private _localEngine: Engine;\r\n\r\n    public _glTFMaterialExporter: _GLTFMaterialExporter;\r\n\r\n    private _extensions: { [name: string]: IGLTFExporterExtensionV2 } = {};\r\n\r\n    private static _ExtensionNames = new Array<string>();\r\n    private static _ExtensionFactories: { [name: string]: (exporter: _Exporter) => IGLTFExporterExtensionV2 } = {};\r\n\r\n    private _applyExtensions<T>(property: any, actionAsync: (extension: IGLTFExporterExtensionV2) => Nullable<T> | undefined): Nullable<T> {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                const exporterProperty = property as any;\r\n                exporterProperty._activeLoaderExtensions = exporterProperty._activeLoaderExtensions || {};\r\n                const activeLoaderExtensions = exporterProperty._activeLoaderExtensions;\r\n                if (!activeLoaderExtensions[name]) {\r\n                    activeLoaderExtensions[name] = true;\r\n\r\n                    try {\r\n                        const result = actionAsync(extension);\r\n                        if (result) {\r\n                            return result;\r\n                        }\r\n                    }\r\n                    finally {\r\n                        delete activeLoaderExtensions[name];\r\n                        delete exporterProperty._activeLoaderExtensions;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    public _extensionsPreExportTextureAsync(context: string, babylonTexture: Texture, mimeType: ImageMimeType): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(babylonTexture, (extension) => extension.preExportTextureAsync && extension.preExportTextureAsync(context, babylonTexture, mimeType));\r\n    }\r\n\r\n    public _extensionsPostExportMeshPrimitiveAsync(context: string, meshPrimitive: IMeshPrimitive, babylonSubMesh: SubMesh, binaryWriter: _BinaryWriter): Nullable<Promise<IMeshPrimitive>> {\r\n        return this._applyExtensions(meshPrimitive, (extension) => extension.postExportMeshPrimitiveAsync && extension.postExportMeshPrimitiveAsync(context, meshPrimitive, babylonSubMesh, binaryWriter));\r\n    }\r\n\r\n    public _extensionsPostExportNodeAsync(context: string, node: INode, babylonNode: Node): Nullable<Promise<INode>> {\r\n        return this._applyExtensions(node, (extension) => extension.postExportNodeAsync && extension.postExportNodeAsync(context, node, babylonNode));\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFExporterExtensionV2) => void): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _extensionsOnExporting(): void {\r\n        this._forEachExtensions((extension) => extension.onExporting && extension.onExporting());\r\n    }\r\n\r\n    /**\r\n     * Load glTF serializer extensions\r\n     */\r\n    private _loadExtensions(): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = _Exporter._ExtensionFactories[name](this);\r\n            this._extensions[name] = extension;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF Exporter instance, which can accept optional exporter options\r\n     * @param babylonScene Babylon scene object\r\n     * @param options Options to modify the behavior of the exporter\r\n     */\r\n    public constructor(babylonScene: Scene, options?: IExportOptions) {\r\n        this._glTF = {\r\n            asset: { generator: \"BabylonJS\", version: \"2.0\" }\r\n        };\r\n        this._babylonScene = babylonScene;\r\n        this._bufferViews = [];\r\n        this._accessors = [];\r\n        this._meshes = [];\r\n        this._scenes = [];\r\n        this._nodes = [];\r\n        this._images = [];\r\n        this._materials = [];\r\n        this._materialMap = [];\r\n        this._textures = [];\r\n        this._samplers = [];\r\n        this._animations = [];\r\n        this._imageData = {};\r\n        this._convertToRightHandedSystem = this._babylonScene.useRightHandedSystem ? false : true;\r\n        const _options = options || {};\r\n        this._shouldExportNode = _options.shouldExportNode ? _options.shouldExportNode : (babylonNode: Node) => true;\r\n        this._animationSampleRate = _options.animationSampleRate ? _options.animationSampleRate : 1 / 60;\r\n\r\n        this._glTFMaterialExporter = new _GLTFMaterialExporter(this);\r\n        this._loadExtensions();\r\n    }\r\n\r\n    /**\r\n     * Registers a glTF exporter extension\r\n     * @param name Name of the extension to export\r\n     * @param factory The factory function that creates the exporter extension\r\n     */\r\n    public static RegisterExtension(name: string, factory: (exporter: _Exporter) => IGLTFExporterExtensionV2): void {\r\n        if (_Exporter.UnregisterExtension(name)) {\r\n            Tools.Warn(`Extension with the name ${name} already exists`);\r\n        }\r\n\r\n        _Exporter._ExtensionFactories[name] = factory;\r\n        _Exporter._ExtensionNames.push(name);\r\n    }\r\n\r\n    /**\r\n     * Un-registers an exporter extension\r\n     * @param name The name fo the exporter extension\r\n     * @returns A boolean indicating whether the extension has been un-registered\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!_Exporter._ExtensionFactories[name]) {\r\n            return false;\r\n        }\r\n        delete _Exporter._ExtensionFactories[name];\r\n\r\n        const index = _Exporter._ExtensionNames.indexOf(name);\r\n        if (index !== -1) {\r\n            _Exporter._ExtensionNames.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Lazy load a local engine with premultiplied alpha set to false\r\n     */\r\n    public _getLocalEngine(): Engine {\r\n        if (!this._localEngine) {\r\n            const localCanvas = document.createElement('canvas');\r\n            localCanvas.id = \"WriteCanvas\";\r\n            localCanvas.width = 2048;\r\n            localCanvas.height = 2048;\r\n            this._localEngine = new Engine(localCanvas, true, { premultipliedAlpha: false, preserveDrawingBuffer: true });\r\n            this._localEngine.setViewport(new Viewport(0, 0, 1, 1));\r\n        }\r\n\r\n        return this._localEngine;\r\n    }\r\n\r\n    private reorderIndicesBasedOnPrimitiveMode(submesh: SubMesh, primitiveMode: number, babylonIndices: IndicesArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                if (!byteOffset) { byteOffset = 0; }\r\n                for (let i = submesh.indexStart, length = submesh.indexStart + submesh.indexCount; i < length; i = i + 3) {\r\n                    const index = byteOffset + i * 4;\r\n                    // swap the second and third indices\r\n                    const secondIndex = binaryWriter.getUInt32(index + 4);\r\n                    const thirdIndex = binaryWriter.getUInt32(index + 8);\r\n                    binaryWriter.setUInt32(thirdIndex, index + 4);\r\n                    binaryWriter.setUInt32(secondIndex, index + 8);\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                for (let i = submesh.indexStart + submesh.indexCount - 1, start = submesh.indexStart; i >= start; --i) {\r\n                    binaryWriter.setUInt32(babylonIndices[i], byteOffset);\r\n                    byteOffset += 4;\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                if (submesh.indexCount >= 3) {\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 2], byteOffset + 4);\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 1], byteOffset + 8);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attribute data based on the primitive mode.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderVertexAttributeDataBasedOnPrimitiveMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter): void {\r\n        if (this._convertToRightHandedSystem && sideOrientation === Material.ClockWiseSideOrientation) {\r\n            switch (primitiveMode) {\r\n                case Material.TriangleFillMode: {\r\n                    this.reorderTriangleFillMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                    break;\r\n                }\r\n                case Material.TriangleStripDrawMode: {\r\n                    this.reorderTriangleStripDrawMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                    break;\r\n                }\r\n                case Material.TriangleFanDrawMode: {\r\n                    this.reorderTriangleFanMode(submesh, primitiveMode, sideOrientation, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle mode order .  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderTriangleFillMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            let stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n            if (submesh.verticesCount % 3 !== 0) {\r\n                Tools.Error('The submesh vertices for the triangle fill mode is not divisible by 3!');\r\n            }\r\n            else {\r\n                let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n                let index = 0;\r\n                switch (vertexBufferKind) {\r\n                    case VertexBuffer.PositionKind:\r\n                    case VertexBuffer.NormalKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.TangentKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.ColorKind: {\r\n                        const size = vertexBuffer.getSize();\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + size) {\r\n                            index = x * stride;\r\n                            if (size === 4) {\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                            }\r\n                            else {\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.UVKind:\r\n                    case VertexBuffer.UV2Kind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                    }\r\n                }\r\n                this.writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter);\r\n            }\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleFillMode: Vertex Buffer Kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle strip order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderTriangleStripDrawMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            const stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    index = submesh.verticesStart;\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        vertexBuffer.getSize() === 4 ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index)) : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this.writeVertexAttributeData(vertexData, byteOffset + 12, vertexBufferKind, meshAttributeArray, binaryWriter);\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleStripDrawMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle fan order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param sideOrientation the winding order of the submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private reorderTriangleFanMode(submesh: SubMesh, primitiveMode: number, sideOrientation: number, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this.getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            let stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            let vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                        vertexBuffer.getSize() === 4 ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index)) : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this.writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, meshAttributeArray, binaryWriter);\r\n        }\r\n        else {\r\n            Tools.Warn(`reorderTriangleFanMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes the vertex attribute data to binary\r\n     * @param vertices The vertices to write to the binary writer\r\n     * @param byteOffset The offset into the binary writer to overwrite binary data\r\n     * @param vertexAttributeKind The vertex attribute type\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param binaryWriter The writer containing the binary data\r\n     */\r\n    private writeVertexAttributeData(vertices: Vector2[] | Vector3[] | Vector4[], byteOffset: number, vertexAttributeKind: string, meshAttributeArray: FloatArray, binaryWriter: _BinaryWriter) {\r\n        for (let vertex of vertices) {\r\n            if (this._convertToRightHandedSystem && !(vertexAttributeKind === VertexBuffer.ColorKind) && !(vertex instanceof Vector2)) {\r\n                if (vertex instanceof Vector3) {\r\n                    if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(vertex);\r\n                    }\r\n                    else if (vertexAttributeKind === VertexBuffer.PositionKind) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(vertex);\r\n                    }\r\n                    else {\r\n                        Tools.Error('Unsupported vertex attribute kind!');\r\n                    }\r\n                }\r\n                else {\r\n                    _GLTFUtilities._GetRightHandedVector4FromRef(vertex);\r\n                }\r\n            }\r\n            if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                vertex.normalize();\r\n            }\r\n            else if (vertexAttributeKind === VertexBuffer.TangentKind && vertex instanceof Vector4) {\r\n                _GLTFUtilities._NormalizeTangentFromRef(vertex);\r\n            }\r\n\r\n            for (let component of vertex.asArray()) {\r\n                binaryWriter.setFloat32(component, byteOffset);\r\n                byteOffset += 4;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes mesh attribute data to a data buffer\r\n     * Returns the bytelength of the data\r\n     * @param vertexBufferKind Indicates what kind of vertex data is being passed in\r\n     * @param meshAttributeArray Array containing the attribute data\r\n     * @param binaryWriter The buffer to write the binary data to\r\n     * @param indices Used to specify the order of the vertex data\r\n     */\r\n    public writeAttributeData(vertexBufferKind: string, meshAttributeArray: FloatArray, byteStride: number, binaryWriter: _BinaryWriter) {\r\n        const stride = byteStride / 4;\r\n        let vertexAttributes: number[][] = [];\r\n        let index: number;\r\n\r\n        switch (vertexBufferKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    if (this._convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedPositionVector3FromRef(vertexData);\r\n                    }\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    if (this._convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(vertexData);\r\n                    }\r\n                    vertexData.normalize();\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector4.FromArray(meshAttributeArray, index);\r\n                    if (this._convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedVector4FromRef(vertexData);\r\n                    }\r\n                    _GLTFUtilities._NormalizeTangentFromRef(vertexData);\r\n\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = stride === 3 ? Vector3.FromArray(meshAttributeArray, index) : Vector4.FromArray(meshAttributeArray, index);\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind:\r\n            case VertexBuffer.UV2Kind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    vertexAttributes.push(this._convertToRightHandedSystem ? [meshAttributeArray[index], meshAttributeArray[index + 1]] : [meshAttributeArray[index], meshAttributeArray[index + 1]]);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + vertexBufferKind);\r\n                vertexAttributes = [];\r\n            }\r\n        }\r\n        for (let vertexAttribute of vertexAttributes) {\r\n            for (let component of vertexAttribute) {\r\n                binaryWriter.setFloat32(component);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates glTF json data\r\n     * @param shouldUseGlb Indicates whether the json should be written for a glb file\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @param prettyPrint Indicates whether the json file should be pretty printed (true) or not (false)\r\n     * @returns json data as string\r\n     */\r\n    private generateJSON(shouldUseGlb: boolean, glTFPrefix?: string, prettyPrint?: boolean): string {\r\n        let buffer: IBuffer = { byteLength: this._totalByteLength };\r\n        let imageName: string;\r\n        let imageData: { data: Uint8Array, mimeType: ImageMimeType };\r\n        let bufferView: IBufferView;\r\n        let byteOffset: number = this._totalByteLength;\r\n\r\n        if (buffer.byteLength) {\r\n            this._glTF.buffers = [buffer];\r\n        }\r\n        if (this._nodes && this._nodes.length) {\r\n            this._glTF.nodes = this._nodes;\r\n        }\r\n        if (this._meshes && this._meshes.length) {\r\n            this._glTF.meshes = this._meshes;\r\n        }\r\n        if (this._scenes && this._scenes.length) {\r\n            this._glTF.scenes = this._scenes;\r\n            this._glTF.scene = 0;\r\n        }\r\n        if (this._bufferViews && this._bufferViews.length) {\r\n            this._glTF.bufferViews = this._bufferViews;\r\n        }\r\n        if (this._accessors && this._accessors.length) {\r\n            this._glTF.accessors = this._accessors;\r\n        }\r\n        if (this._animations && this._animations.length) {\r\n            this._glTF.animations = this._animations;\r\n        }\r\n        if (this._materials && this._materials.length) {\r\n            this._glTF.materials = this._materials;\r\n        }\r\n        if (this._textures && this._textures.length) {\r\n            this._glTF.textures = this._textures;\r\n        }\r\n        if (this._samplers && this._samplers.length) {\r\n            this._glTF.samplers = this._samplers;\r\n        }\r\n        if (this._images && this._images.length) {\r\n            if (!shouldUseGlb) {\r\n                this._glTF.images = this._images;\r\n            }\r\n            else {\r\n                this._glTF.images = [];\r\n\r\n                this._images.forEach((image) => {\r\n                    if (image.uri) {\r\n                        imageData = this._imageData[image.uri];\r\n                        imageName = image.uri.split('.')[0] + \" image\";\r\n                        bufferView = _GLTFUtilities._CreateBufferView(0, byteOffset, imageData.data.length, undefined, imageName);\r\n                        byteOffset += imageData.data.buffer.byteLength;\r\n                        this._bufferViews.push(bufferView);\r\n                        image.bufferView = this._bufferViews.length - 1;\r\n                        image.name = imageName;\r\n                        image.mimeType = imageData.mimeType;\r\n                        image.uri = undefined;\r\n                        if (!this._glTF.images) {\r\n                            this._glTF.images = [];\r\n                        }\r\n                        this._glTF.images.push(image);\r\n                    }\r\n                });\r\n                // Replace uri with bufferview and mime type for glb\r\n                buffer.byteLength = byteOffset;\r\n            }\r\n        }\r\n\r\n        if (!shouldUseGlb) {\r\n            buffer.uri = glTFPrefix + \".bin\";\r\n        }\r\n\r\n        const jsonText = prettyPrint ? JSON.stringify(this._glTF, null, 2) : JSON.stringify(this._glTF);\r\n\r\n        return jsonText;\r\n    }\r\n\r\n    /**\r\n     * Generates data for .gltf and .bin files based on the glTF prefix string\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @returns GLTFData with glTF file data\r\n     */\r\n    public _generateGLTFAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            this._extensionsOnExporting();\r\n            const jsonText = this.generateJSON(false, glTFPrefix, true);\r\n            const bin = new Blob([binaryBuffer], { type: 'application/octet-stream' });\r\n\r\n            const glTFFileName = glTFPrefix + '.gltf';\r\n            const glTFBinFile = glTFPrefix + '.bin';\r\n\r\n            const container = new GLTFData();\r\n\r\n            container.glTFFiles[glTFFileName] = jsonText;\r\n            container.glTFFiles[glTFBinFile] = bin;\r\n\r\n            if (this._imageData) {\r\n                for (let image in this._imageData) {\r\n                    container.glTFFiles[image] = new Blob([this._imageData[image].data], { type: this._imageData[image].mimeType });\r\n                }\r\n            }\r\n\r\n            return container;\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Creates a binary buffer for glTF\r\n     * @returns array buffer for binary data\r\n     */\r\n    private _generateBinaryAsync(): Promise<ArrayBuffer> {\r\n        let binaryWriter = new _BinaryWriter(4);\r\n        return this.createSceneAsync(this._babylonScene, binaryWriter).then(() => {\r\n            if (this._localEngine) {\r\n                this._localEngine.dispose();\r\n            }\r\n            return binaryWriter.getArrayBuffer();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Pads the number to a multiple of 4\r\n     * @param num number to pad\r\n     * @returns padded number\r\n     */\r\n    private _getPadding(num: number): number {\r\n        let remainder = num % 4;\r\n        let padding = remainder === 0 ? remainder : 4 - remainder;\r\n\r\n        return padding;\r\n    }\r\n\r\n    /**\r\n     * Generates a glb file from the json and binary data\r\n     * Returns an object with the glb file name as the key and data as the value\r\n     * @param glTFPrefix\r\n     * @returns object with glb filename as key and data as value\r\n     */\r\n    public _generateGLBAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            this._extensionsOnExporting();\r\n            const jsonText = this.generateJSON(true);\r\n            const glbFileName = glTFPrefix + '.glb';\r\n            const headerLength = 12;\r\n            const chunkLengthPrefix = 8;\r\n            const jsonLength = jsonText.length;\r\n            let imageByteLength = 0;\r\n\r\n            for (let key in this._imageData) {\r\n                imageByteLength += this._imageData[key].data.byteLength;\r\n            }\r\n            const jsonPadding = this._getPadding(jsonLength);\r\n            const binPadding = this._getPadding(binaryBuffer.byteLength);\r\n            const imagePadding = this._getPadding(imageByteLength);\r\n\r\n            const byteLength = headerLength + (2 * chunkLengthPrefix) + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding + imageByteLength + imagePadding;\r\n\r\n            //header\r\n            const headerBuffer = new ArrayBuffer(headerLength);\r\n            const headerBufferView = new DataView(headerBuffer);\r\n            headerBufferView.setUint32(0, 0x46546C67, true); //glTF\r\n            headerBufferView.setUint32(4, 2, true); // version\r\n            headerBufferView.setUint32(8, byteLength, true); // total bytes in file\r\n\r\n            //json chunk\r\n            const jsonChunkBuffer = new ArrayBuffer(chunkLengthPrefix + jsonLength + jsonPadding);\r\n            const jsonChunkBufferView = new DataView(jsonChunkBuffer);\r\n            jsonChunkBufferView.setUint32(0, jsonLength + jsonPadding, true);\r\n            jsonChunkBufferView.setUint32(4, 0x4E4F534A, true);\r\n\r\n            //json chunk bytes\r\n            const jsonData = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix);\r\n            for (let i = 0; i < jsonLength; ++i) {\r\n                jsonData[i] = jsonText.charCodeAt(i);\r\n            }\r\n\r\n            //json padding\r\n            const jsonPaddingView = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix + jsonLength);\r\n            for (let i = 0; i < jsonPadding; ++i) {\r\n                jsonPaddingView[i] = 0x20;\r\n            }\r\n\r\n            //binary chunk\r\n            const binaryChunkBuffer = new ArrayBuffer(chunkLengthPrefix);\r\n            const binaryChunkBufferView = new DataView(binaryChunkBuffer);\r\n            binaryChunkBufferView.setUint32(0, binaryBuffer.byteLength + imageByteLength + imagePadding, true);\r\n            binaryChunkBufferView.setUint32(4, 0x004E4942, true);\r\n\r\n            // binary padding\r\n            const binPaddingBuffer = new ArrayBuffer(binPadding);\r\n            const binPaddingView = new Uint8Array(binPaddingBuffer);\r\n            for (let i = 0; i < binPadding; ++i) {\r\n                binPaddingView[i] = 0;\r\n            }\r\n\r\n            const imagePaddingBuffer = new ArrayBuffer(imagePadding);\r\n            const imagePaddingView = new Uint8Array(imagePaddingBuffer);\r\n            for (let i = 0; i < imagePadding; ++i) {\r\n                imagePaddingView[i] = 0;\r\n            }\r\n\r\n            const glbData = [headerBuffer, jsonChunkBuffer, binaryChunkBuffer, binaryBuffer];\r\n\r\n            // binary data\r\n            for (let key in this._imageData) {\r\n                glbData.push(this._imageData[key].data.buffer);\r\n            }\r\n            glbData.push(binPaddingBuffer);\r\n\r\n            glbData.push(imagePaddingBuffer);\r\n\r\n            const glbFile = new Blob(glbData, { type: 'application/octet-stream' });\r\n\r\n            const container = new GLTFData();\r\n            container.glTFFiles[glbFileName] = glbFile;\r\n\r\n            if (this._localEngine != null) {\r\n                this._localEngine.dispose();\r\n            }\r\n\r\n            return container;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the TRS for each node\r\n     * @param node glTF Node for storing the transformation data\r\n     * @param babylonTransformNode Babylon mesh used as the source for the transformation data\r\n     */\r\n    private setNodeTransformation(node: INode, babylonTransformNode: TransformNode): void {\r\n        if (!babylonTransformNode.getPivotPoint().equalsToFloats(0, 0, 0)) {\r\n            Tools.Warn(\"Pivot points are not supported in the glTF serializer\");\r\n        }\r\n        if (!babylonTransformNode.position.equalsToFloats(0, 0, 0)) {\r\n            node.translation = this._convertToRightHandedSystem ? _GLTFUtilities._GetRightHandedPositionVector3(babylonTransformNode.position).asArray() : babylonTransformNode.position.asArray();\r\n        }\r\n\r\n        if (!babylonTransformNode.scaling.equalsToFloats(1, 1, 1)) {\r\n            node.scale = babylonTransformNode.scaling.asArray();\r\n        }\r\n\r\n        let rotationQuaternion = Quaternion.RotationYawPitchRoll(babylonTransformNode.rotation.y, babylonTransformNode.rotation.x, babylonTransformNode.rotation.z);\r\n        if (babylonTransformNode.rotationQuaternion) {\r\n            rotationQuaternion.multiplyInPlace(babylonTransformNode.rotationQuaternion);\r\n        }\r\n        if (!(rotationQuaternion.x === 0 && rotationQuaternion.y === 0 && rotationQuaternion.z === 0 && rotationQuaternion.w === 1)) {\r\n            if (this._convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);\r\n\r\n            }\r\n            node.rotation = rotationQuaternion.normalize().asArray();\r\n        }\r\n    }\r\n\r\n    private getVertexBufferFromMesh(attributeKind: string, bufferMesh: Mesh): Nullable<VertexBuffer> {\r\n        if (bufferMesh.isVerticesDataPresent(attributeKind)) {\r\n            const vertexBuffer = bufferMesh.getVertexBuffer(attributeKind);\r\n            if (vertexBuffer) {\r\n                return vertexBuffer;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a bufferview based on the vertices type for the Babylon mesh\r\n     * @param kind Indicates the type of vertices data\r\n     * @param babylonTransformNode The Babylon mesh to get the vertices data from\r\n     * @param binaryWriter The buffer to write the bufferview data to\r\n     */\r\n    private createBufferViewKind(kind: string, babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter, byteStride: number) {\r\n        const bufferMesh = babylonTransformNode instanceof Mesh ?\r\n            babylonTransformNode as Mesh : babylonTransformNode instanceof InstancedMesh ?\r\n                (babylonTransformNode as InstancedMesh).sourceMesh : null;\r\n\r\n        if (bufferMesh) {\r\n            const vertexData = bufferMesh.getVerticesData(kind);\r\n\r\n            if (vertexData) {\r\n                const byteLength = vertexData.length * 4;\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, kind + \" - \" + bufferMesh.name);\r\n                this._bufferViews.push(bufferView);\r\n\r\n                this.writeAttributeData(\r\n                    kind,\r\n                    vertexData,\r\n                    byteStride,\r\n                    binaryWriter\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The primitive mode of the Babylon mesh\r\n     * @param babylonMesh The BabylonJS mesh\r\n     */\r\n    private getMeshPrimitiveMode(babylonMesh: AbstractMesh): number {\r\n        if (babylonMesh instanceof LinesMesh) {\r\n            return Material.LineListDrawMode;\r\n        }\r\n        return babylonMesh.material ? babylonMesh.material.fillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the primitive mode of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param primitiveMode The primitive mode\r\n     */\r\n    private setPrimitiveMode(meshPrimitive: IMeshPrimitive, primitiveMode: number) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                // glTF defaults to using Triangle Mode\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_STRIP;\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_FAN;\r\n                break;\r\n            }\r\n            case Material.PointListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n            }\r\n            case Material.PointFillMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n                break;\r\n            }\r\n            case Material.LineLoopDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_LOOP;\r\n                break;\r\n            }\r\n            case Material.LineListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINES;\r\n                break;\r\n            }\r\n            case Material.LineStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_STRIP;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex attribute accessor based of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param attributeKind vertex attribute\r\n     * @returns boolean specifying if uv coordinates are present\r\n     */\r\n    private setAttributeKind(meshPrimitive: IMeshPrimitive, attributeKind: string): void {\r\n        switch (attributeKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                meshPrimitive.attributes.POSITION = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                meshPrimitive.attributes.NORMAL = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                meshPrimitive.attributes.COLOR_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                meshPrimitive.attributes.TANGENT = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind: {\r\n                meshPrimitive.attributes.TEXCOORD_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UV2Kind: {\r\n                meshPrimitive.attributes.TEXCOORD_1 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + attributeKind);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets data for the primitive attributes of each submesh\r\n     * @param mesh glTF Mesh object to store the primitive attribute information\r\n     * @param babylonTransformNode Babylon mesh to get the primitive attribute data from\r\n     * @param binaryWriter Buffer to write the attribute data to\r\n     */\r\n    private setPrimitiveAttributesAsync(mesh: IMesh, babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter): Promise<void> {\r\n        let promises: Promise<IMeshPrimitive>[] = [];\r\n        let bufferMesh: Nullable<Mesh> = null;\r\n        let bufferView: IBufferView;\r\n        let uvCoordsPresent: boolean;\r\n        let minMax: { min: Nullable<number[]>, max: Nullable<number[]> };\r\n\r\n        if (babylonTransformNode instanceof Mesh) {\r\n            bufferMesh = (babylonTransformNode as Mesh);\r\n        }\r\n        else if (babylonTransformNode instanceof InstancedMesh) {\r\n            bufferMesh = (babylonTransformNode as InstancedMesh).sourceMesh;\r\n        }\r\n        const attributeData: _IVertexAttributeData[] = [\r\n            { kind: VertexBuffer.PositionKind, accessorType: AccessorType.VEC3, byteStride: 12 },\r\n            { kind: VertexBuffer.NormalKind, accessorType: AccessorType.VEC3, byteStride: 12 },\r\n            { kind: VertexBuffer.ColorKind, accessorType: AccessorType.VEC4, byteStride: 16 },\r\n            { kind: VertexBuffer.TangentKind, accessorType: AccessorType.VEC4, byteStride: 16 },\r\n            { kind: VertexBuffer.UVKind, accessorType: AccessorType.VEC2, byteStride: 8 },\r\n            { kind: VertexBuffer.UV2Kind, accessorType: AccessorType.VEC2, byteStride: 8 },\r\n        ];\r\n\r\n        if (bufferMesh) {\r\n            let indexBufferViewIndex: Nullable<number> = null;\r\n            const primitiveMode = this.getMeshPrimitiveMode(bufferMesh);\r\n            let vertexAttributeBufferViews: { [attributeKind: string]: number } = {};\r\n\r\n            // For each BabylonMesh, create bufferviews for each 'kind'\r\n            for (const attribute of attributeData) {\r\n                const attributeKind = attribute.kind;\r\n                if (bufferMesh.isVerticesDataPresent(attributeKind)) {\r\n                    const vertexBuffer = this.getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                    attribute.byteStride = vertexBuffer ? vertexBuffer.getSize() * 4 : VertexBuffer.DeduceStride(attributeKind) * 4;\r\n                    if (attribute.byteStride === 12) {\r\n                        attribute.accessorType = AccessorType.VEC3;\r\n                    }\r\n\r\n                    this.createBufferViewKind(attributeKind, babylonTransformNode, binaryWriter, attribute.byteStride);\r\n                    attribute.bufferViewIndex = this._bufferViews.length - 1;\r\n                    vertexAttributeBufferViews[attributeKind] = attribute.bufferViewIndex;\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.getTotalIndices()) {\r\n                const indices = bufferMesh.getIndices();\r\n                if (indices) {\r\n                    const byteLength = indices.length * 4;\r\n                    bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, \"Indices - \" + bufferMesh.name);\r\n                    this._bufferViews.push(bufferView);\r\n                    indexBufferViewIndex = this._bufferViews.length - 1;\r\n\r\n                    for (let k = 0, length = indices.length; k < length; ++k) {\r\n                        binaryWriter.setUInt32(indices[k]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.subMeshes) {\r\n                // go through all mesh primitives (submeshes)\r\n                for (const submesh of bufferMesh.subMeshes) {\r\n                    uvCoordsPresent = false;\r\n                    let babylonMaterial = submesh.getMaterial() || bufferMesh.getScene().defaultMaterial;\r\n\r\n                    let materialIndex: Nullable<number> = null;\r\n                    if (babylonMaterial) {\r\n                        if (bufferMesh instanceof LinesMesh) {\r\n                            // get the color from the lines mesh and set it in the material\r\n                            const material: IMaterial = {\r\n                                name: bufferMesh.name + ' material'\r\n                            };\r\n                            if (!bufferMesh.color.equals(Color3.White()) || bufferMesh.alpha < 1) {\r\n                                material.pbrMetallicRoughness = {\r\n                                    baseColorFactor: bufferMesh.color.asArray().concat([bufferMesh.alpha])\r\n                                };\r\n                            }\r\n                            this._materials.push(material);\r\n                            materialIndex = this._materials.length - 1;\r\n                        }\r\n                        else if (babylonMaterial instanceof MultiMaterial) {\r\n                            const subMaterial = babylonMaterial.subMaterials[submesh.materialIndex];\r\n                            if (subMaterial) {\r\n                                babylonMaterial = subMaterial;\r\n                                materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                            }\r\n                        }\r\n                        else {\r\n                            materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                        }\r\n                    }\r\n\r\n                    let glTFMaterial: Nullable<IMaterial> = materialIndex != null ? this._materials[materialIndex] : null;\r\n\r\n                    const meshPrimitive: IMeshPrimitive = { attributes: {} };\r\n                    this.setPrimitiveMode(meshPrimitive, primitiveMode);\r\n\r\n                    for (const attribute of attributeData) {\r\n                        const attributeKind = attribute.kind;\r\n                        if (attributeKind === VertexBuffer.UVKind || attributeKind === VertexBuffer.UV2Kind) {\r\n                            if (glTFMaterial && !this._glTFMaterialExporter._hasTexturesPresent(glTFMaterial)) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        let vertexData = bufferMesh.getVerticesData(attributeKind);\r\n                        if (vertexData) {\r\n                            const vertexBuffer = this.getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                            if (vertexBuffer) {\r\n                                const stride = vertexBuffer.getSize();\r\n                                const bufferViewIndex = attribute.bufferViewIndex;\r\n                                if (bufferViewIndex != undefined) { // check to see if bufferviewindex has a numeric value assigned.\r\n                                    minMax = { min: null, max: null };\r\n                                    if (attributeKind == VertexBuffer.PositionKind) {\r\n                                        minMax = _GLTFUtilities._CalculateMinMaxPositions(vertexData, 0, vertexData.length / stride, this._convertToRightHandedSystem);\r\n                                    }\r\n                                    const accessor = _GLTFUtilities._CreateAccessor(bufferViewIndex, attributeKind + \" - \" + babylonTransformNode.name, attribute.accessorType, AccessorComponentType.FLOAT, vertexData.length / stride, 0, minMax.min, minMax.max);\r\n                                    this._accessors.push(accessor);\r\n                                    this.setAttributeKind(meshPrimitive, attributeKind);\r\n                                    if (meshPrimitive.attributes.TEXCOORD_0 != null || meshPrimitive.attributes.TEXCOORD_1 != null) {\r\n                                        uvCoordsPresent = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (indexBufferViewIndex) {\r\n                        // Create accessor\r\n                        const accessor = _GLTFUtilities._CreateAccessor(indexBufferViewIndex, \"indices - \" + babylonTransformNode.name, AccessorType.SCALAR, AccessorComponentType.UNSIGNED_INT, submesh.indexCount, submesh.indexStart * 4, null, null);\r\n                        this._accessors.push(accessor);\r\n                        meshPrimitive.indices = this._accessors.length - 1;\r\n                    }\r\n                    if (materialIndex != null && Object.keys(meshPrimitive.attributes).length > 0) {\r\n                        let sideOrientation = babylonMaterial.sideOrientation;\r\n\r\n                        // Only reverse the winding if we have a clockwise winding\r\n                        if (sideOrientation === Material.ClockWiseSideOrientation) {\r\n                            let byteOffset = indexBufferViewIndex != null ? this._bufferViews[indexBufferViewIndex].byteOffset : null;\r\n                            if (byteOffset == null) { byteOffset = 0; }\r\n                            let babylonIndices: Nullable<IndicesArray> = null;\r\n                            if (indexBufferViewIndex != null) {\r\n                                babylonIndices = bufferMesh.getIndices();\r\n                            }\r\n                            if (babylonIndices) {\r\n                                this.reorderIndicesBasedOnPrimitiveMode(submesh, primitiveMode, babylonIndices, byteOffset, binaryWriter);\r\n                            }\r\n                            else {\r\n                                for (let attribute of attributeData) {\r\n                                    let vertexData = bufferMesh.getVerticesData(attribute.kind);\r\n                                    if (vertexData) {\r\n                                        let byteOffset = this._bufferViews[vertexAttributeBufferViews[attribute.kind]].byteOffset;\r\n                                        if (!byteOffset) {\r\n                                            byteOffset = 0;\r\n                                        }\r\n                                        this.reorderVertexAttributeDataBasedOnPrimitiveMode(submesh, primitiveMode, sideOrientation, attribute.kind, vertexData, byteOffset, binaryWriter);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (!uvCoordsPresent && this._glTFMaterialExporter._hasTexturesPresent(this._materials[materialIndex])) {\r\n                            const newMat = this._glTFMaterialExporter._stripTexturesFromMaterial(this._materials[materialIndex]);\r\n                            this._materials.push(newMat);\r\n                            materialIndex = this._materials.length - 1;\r\n                        }\r\n\r\n                        meshPrimitive.material = materialIndex;\r\n\r\n                    }\r\n                    mesh.primitives.push(meshPrimitive);\r\n\r\n                    const promise = this._extensionsPostExportMeshPrimitiveAsync(\"postExport\", meshPrimitive, submesh, binaryWriter);\r\n                    if (promise) {\r\n                        promises.push();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            /* do nothing */\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF scene based on the array of meshes\r\n     * Returns the the total byte offset\r\n     * @param babylonScene Babylon scene to get the mesh data from\r\n     * @param binaryWriter Buffer to write binary data to\r\n     */\r\n    private createSceneAsync(babylonScene: Scene, binaryWriter: _BinaryWriter): Promise<void> {\r\n        const scene: IScene = { nodes: [] };\r\n        let glTFNodeIndex: number;\r\n        let glTFNode: INode;\r\n        let directDescendents: Node[];\r\n        const nodes: Node[] = [...babylonScene.transformNodes, ...babylonScene.meshes, ...babylonScene.lights];\r\n\r\n        return this._glTFMaterialExporter._convertMaterialsToGLTFAsync(babylonScene.materials, ImageMimeType.PNG, true).then(() => {\r\n            return this.createNodeMapAndAnimationsAsync(babylonScene, nodes, this._shouldExportNode, binaryWriter).then((nodeMap) => {\r\n                this._nodeMap = nodeMap;\r\n\r\n                this._totalByteLength = binaryWriter.getByteOffset();\r\n                if (this._totalByteLength == undefined) {\r\n                    throw new Error(\"undefined byte length!\");\r\n                }\r\n\r\n                // Build Hierarchy with the node map.\r\n                for (let babylonNode of nodes) {\r\n                    glTFNodeIndex = this._nodeMap[babylonNode.uniqueId];\r\n                    if (glTFNodeIndex !== undefined) {\r\n                        glTFNode = this._nodes[glTFNodeIndex];\r\n                        if (!babylonNode.parent) {\r\n                            if (!this._shouldExportNode(babylonNode)) {\r\n                                Tools.Log(\"Omitting \" + babylonNode.name + \" from scene.\");\r\n                            }\r\n                            else {\r\n                                if (this._convertToRightHandedSystem) {\r\n                                    if (glTFNode.translation) {\r\n                                        glTFNode.translation[2] *= -1;\r\n                                        glTFNode.translation[0] *= -1;\r\n                                    }\r\n                                    glTFNode.rotation = glTFNode.rotation ? Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(glTFNode.rotation)).asArray() : (Quaternion.FromArray([0, 1, 0, 0])).asArray();\r\n                                }\r\n\r\n                                scene.nodes.push(glTFNodeIndex);\r\n                            }\r\n                        }\r\n\r\n                        directDescendents = babylonNode.getDescendants(true);\r\n                        if (!glTFNode.children && directDescendents && directDescendents.length) {\r\n                            const children: number[] = [];\r\n                            for (let descendent of directDescendents) {\r\n                                if (this._nodeMap[descendent.uniqueId] != null) {\r\n                                    children.push(this._nodeMap[descendent.uniqueId]);\r\n                                }\r\n                            }\r\n                            if (children.length) {\r\n                                glTFNode.children = children;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (scene.nodes.length) {\r\n                    this._scenes.push(scene);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a mapping of Node unique id to node index and handles animations\r\n     * @param babylonScene Babylon Scene\r\n     * @param nodes Babylon transform nodes\r\n     * @param shouldExportNode Callback specifying if a transform node should be exported\r\n     * @param binaryWriter Buffer to write binary data to\r\n     * @returns Node mapping of unique id to index\r\n     */\r\n    private createNodeMapAndAnimationsAsync(babylonScene: Scene, nodes: Node[], shouldExportNode: (babylonNode: Node) => boolean, binaryWriter: _BinaryWriter): Promise<{ [key: number]: number }> {\r\n        let promiseChain = Promise.resolve();\r\n        const nodeMap: { [key: number]: number } = {};\r\n        let nodeIndex: number;\r\n        let runtimeGLTFAnimation: IAnimation = {\r\n            name: 'runtime animations',\r\n            channels: [],\r\n            samplers: []\r\n        };\r\n        let idleGLTFAnimations: IAnimation[] = [];\r\n\r\n        for (let babylonNode of nodes) {\r\n            if (shouldExportNode(babylonNode)) {\r\n                promiseChain = promiseChain.then(() => {\r\n                    return this.createNodeAsync(babylonNode, binaryWriter).then((node) => {\r\n                        const promise = this._extensionsPostExportNodeAsync(\"createNodeAsync\", node, babylonNode);\r\n                        if (promise == null) {\r\n                            Tools.Warn(`Not exporting node ${babylonNode.name}`);\r\n                            return Promise.resolve();\r\n                        }\r\n                        else {\r\n                            return promise.then((node) => {\r\n                                const directDescendents = babylonNode.getDescendants(true, (node: Node) => { return (node instanceof Node); });\r\n                                if (directDescendents.length || node.mesh != null || (node.extensions)) {\r\n                                    this._nodes.push(node);\r\n                                    nodeIndex = this._nodes.length - 1;\r\n                                    nodeMap[babylonNode.uniqueId] = nodeIndex;\r\n                                }\r\n\r\n                                if (!babylonScene.animationGroups.length && babylonNode.animations.length) {\r\n                                    _GLTFAnimation._CreateNodeAnimationFromNodeAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, nodeMap, this._nodes, binaryWriter, this._bufferViews, this._accessors, this._convertToRightHandedSystem, this._animationSampleRate);\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                `Excluding node ${babylonNode.name}`;\r\n            }\r\n        }\r\n\r\n        return promiseChain.then(() => {\r\n            if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {\r\n                this._animations.push(runtimeGLTFAnimation);\r\n            }\r\n            idleGLTFAnimations.forEach((idleGLTFAnimation) => {\r\n                if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {\r\n                    this._animations.push(idleGLTFAnimation);\r\n                }\r\n            });\r\n\r\n            if (babylonScene.animationGroups.length) {\r\n                _GLTFAnimation._CreateNodeAnimationFromAnimationGroups(babylonScene, this._animations, nodeMap, this._nodes, binaryWriter, this._bufferViews, this._accessors, this._convertToRightHandedSystem, this._animationSampleRate);\r\n            }\r\n\r\n            return nodeMap;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF node from a Babylon mesh\r\n     * @param babylonMesh Source Babylon mesh\r\n     * @param binaryWriter Buffer for storing geometry data\r\n     * @returns glTF node\r\n     */\r\n    private createNodeAsync(babylonNode: Node, binaryWriter: _BinaryWriter): Promise<INode> {\r\n        return Promise.resolve().then(() => {\r\n            // create node to hold translation/rotation/scale and the mesh\r\n            const node: INode = {};\r\n            // create mesh\r\n            const mesh: IMesh = { primitives: [] };\r\n\r\n            if (babylonNode.name) {\r\n                node.name = babylonNode.name;\r\n            }\r\n\r\n            if (babylonNode instanceof TransformNode) {\r\n                // Set transformation\r\n                this.setNodeTransformation(node, babylonNode);\r\n\r\n                return this.setPrimitiveAttributesAsync(mesh, babylonNode, binaryWriter).then(() => {\r\n                    if (mesh.primitives.length) {\r\n                        this._meshes.push(mesh);\r\n                        node.mesh = this._meshes.length - 1;\r\n                    }\r\n                    return node;\r\n                });\r\n            }\r\n            else {\r\n                return node;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * @hidden\r\n *\r\n * Stores glTF binary data.  If the array buffer byte length is exceeded, it doubles in size dynamically\r\n */\r\nexport class _BinaryWriter {\r\n    /**\r\n     * Array buffer which stores all binary data\r\n     */\r\n    private _arrayBuffer: ArrayBuffer;\r\n    /**\r\n     * View of the array buffer\r\n     */\r\n    private _dataView: DataView;\r\n    /**\r\n     * byte offset of data in array buffer\r\n     */\r\n    private _byteOffset: number;\r\n    /**\r\n     * Initialize binary writer with an initial byte length\r\n     * @param byteLength Initial byte length of the array buffer\r\n     */\r\n    constructor(byteLength: number) {\r\n        this._arrayBuffer = new ArrayBuffer(byteLength);\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n        this._byteOffset = 0;\r\n    }\r\n    /**\r\n     * Resize the array buffer to the specified byte length\r\n     * @param byteLength\r\n     */\r\n    private resizeBuffer(byteLength: number): ArrayBuffer {\r\n        let newBuffer = new ArrayBuffer(byteLength);\r\n        let oldUint8Array = new Uint8Array(this._arrayBuffer);\r\n        let newUint8Array = new Uint8Array(newBuffer);\r\n        for (let i = 0, length = newUint8Array.byteLength; i < length; ++i) {\r\n            newUint8Array[i] = oldUint8Array[i];\r\n        }\r\n        this._arrayBuffer = newBuffer;\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n\r\n        return newBuffer;\r\n    }\r\n    /**\r\n     * Get an array buffer with the length of the byte offset\r\n     * @returns ArrayBuffer resized to the byte offset\r\n     */\r\n    public getArrayBuffer(): ArrayBuffer {\r\n        return this.resizeBuffer(this.getByteOffset());\r\n    }\r\n    /**\r\n     * Get the byte offset of the array buffer\r\n     * @returns byte offset\r\n     */\r\n    public getByteOffset(): number {\r\n        if (this._byteOffset == undefined) {\r\n            throw new Error(\"Byte offset is undefined!\");\r\n        }\r\n        return this._byteOffset;\r\n    }\r\n    /**\r\n     * Stores an UInt8 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt8(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint8(byteOffset, entry);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            }\r\n        }\r\n        else {\r\n            if (this._byteOffset + 1 > this._arrayBuffer.byteLength) {\r\n                this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint8(this._byteOffset++, entry);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets an UInt32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public getUInt32(byteOffset: number): number {\r\n        if (byteOffset < this._byteOffset) {\r\n            return this._dataView.getUint32(byteOffset, true);\r\n        }\r\n        else {\r\n            Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            throw new Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n        }\r\n    }\r\n\r\n    public getVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            vector3.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector3.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector3.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n        }\r\n    }\r\n\r\n    public setVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            this._dataView.setFloat32(byteOffset, vector3.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector3.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector3.z, true);\r\n        }\r\n    }\r\n\r\n    public getVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            vector4.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector4.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector4.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n            vector4.w = this._dataView.getFloat32(byteOffset + 12, true);\r\n        }\r\n    }\r\n\r\n    public setVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        }\r\n        else {\r\n            this._dataView.setFloat32(byteOffset, vector4.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector4.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector4.z, true);\r\n            this._dataView.setFloat32(byteOffset + 12, vector4.w, true);\r\n        }\r\n    }\r\n    /**\r\n     * Stores a Float32 in the array buffer\r\n     * @param entry\r\n     */\r\n    public setFloat32(entry: number, byteOffset?: number) {\r\n        if (isNaN(entry)) {\r\n            Tools.Error('Invalid data being written!');\r\n        }\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setFloat32(byteOffset, entry, true);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary length!');\r\n            }\r\n        }\r\n        if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n            this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n        }\r\n        this._dataView.setFloat32(this._byteOffset, entry, true);\r\n        this._byteOffset += 4;\r\n    }\r\n    /**\r\n     * Stores an UInt32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt32(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint32(byteOffset, entry, true);\r\n            }\r\n            else {\r\n                Tools.Error('BinaryWriter: byteoffset is greater than the current binary buffer length!');\r\n            }\r\n        }\r\n        else {\r\n            if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n                this.resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint32(this._byteOffset, entry, true);\r\n            this._byteOffset += 4;\r\n        }\r\n    }\r\n}"]}