import { Vector3, Color3, Quaternion } from "@babylonjs/core/Maths/math";
import { Light } from "@babylonjs/core/Lights/light";
import { ShadowLight } from "@babylonjs/core/Lights/shadowLight";
import { _Exporter } from "../glTFExporter";
import { Logger } from "@babylonjs/core/Misc/logger";
import { _GLTFUtilities } from "../glTFUtilities";
var NAME = "KHR_lights_punctual";
var LightType;
(function (LightType) {
    LightType["DIRECTIONAL"] = "directional";
    LightType["POINT"] = "point";
    LightType["SPOT"] = "spot";
})(LightType || (LightType = {}));
/**
 * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md)
 */
var KHR_lights_punctual = /** @class */ (function () {
    /** @hidden */
    function KHR_lights_punctual(exporter) {
        /** The name of this extension. */
        this.name = NAME;
        /** Defines whether this extension is enabled. */
        this.enabled = true;
        /** Defines whether this extension is required */
        this.required = false;
        this._exporter = exporter;
    }
    /** @hidden */
    KHR_lights_punctual.prototype.dispose = function () {
        delete this._exporter;
        delete this._lights;
    };
    /** @hidden */
    KHR_lights_punctual.prototype.onExporting = function () {
        if (this._lights) {
            if (this._exporter._glTF.extensionsUsed == null) {
                this._exporter._glTF.extensionsUsed = [];
            }
            if (this._exporter._glTF.extensionsUsed.indexOf(NAME) === -1) {
                this._exporter._glTF.extensionsUsed.push(NAME);
            }
            if (this.required) {
                if (this._exporter._glTF.extensionsRequired == null) {
                    this._exporter._glTF.extensionsRequired = [];
                }
                if (this._exporter._glTF.extensionsRequired.indexOf(NAME) === -1) {
                    this._exporter._glTF.extensionsRequired.push(NAME);
                }
            }
            if (this._exporter._glTF.extensions == null) {
                this._exporter._glTF.extensions = {};
            }
            this._exporter._glTF.extensions[NAME] = this._lights;
        }
    };
    /**
     * Define this method to modify the default behavior when exporting a node
     * @param context The context when exporting the node
     * @param node glTF node
     * @param babylonNode BabylonJS node
     * @returns nullable INode promise
     */
    KHR_lights_punctual.prototype.postExportNodeAsync = function (context, node, babylonNode) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (babylonNode instanceof ShadowLight) {
                var babylonLight = babylonNode;
                var light = void 0;
                var lightType = (babylonLight.getTypeID() == Light.LIGHTTYPEID_POINTLIGHT ? LightType.POINT : (babylonLight.getTypeID() == Light.LIGHTTYPEID_DIRECTIONALLIGHT ? LightType.DIRECTIONAL : (babylonLight.getTypeID() == Light.LIGHTTYPEID_SPOTLIGHT ? LightType.SPOT : null)));
                if (lightType == null) {
                    Logger.Warn(context + ": Light " + babylonLight.name + " is not supported in " + NAME);
                }
                else {
                    var lightPosition = babylonLight.position.clone();
                    if (!lightPosition.equals(Vector3.Zero())) {
                        if (_this._exporter._convertToRightHandedSystem) {
                            _GLTFUtilities._GetRightHandedPositionVector3FromRef(lightPosition);
                        }
                        node.translation = lightPosition.asArray();
                    }
                    if (lightType !== LightType.POINT) {
                        var localAxis = babylonLight.direction;
                        var yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;
                        var len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);
                        var pitch = -Math.atan2(localAxis.y, len);
                        var lightRotationQuaternion = Quaternion.RotationYawPitchRoll(yaw, pitch, 0);
                        if (_this._exporter._convertToRightHandedSystem) {
                            _GLTFUtilities._GetRightHandedQuaternionFromRef(lightRotationQuaternion);
                        }
                        if (!lightRotationQuaternion.equals(Quaternion.Identity())) {
                            node.rotation = lightRotationQuaternion.asArray();
                        }
                    }
                    if (babylonLight.falloffType !== Light.FALLOFF_GLTF) {
                        Logger.Warn(context + ": Light falloff for " + babylonLight.name + " does not match the " + NAME + " specification!");
                    }
                    light = {
                        type: lightType
                    };
                    if (!babylonLight.diffuse.equals(Color3.White())) {
                        light.color = babylonLight.diffuse.asArray();
                    }
                    if (babylonLight.intensity !== 1.0) {
                        light.intensity = babylonLight.intensity;
                    }
                    if (babylonLight.range !== Number.MAX_VALUE) {
                        light.range = babylonLight.range;
                    }
                    if (lightType === LightType.SPOT) {
                        var babylonSpotLight = babylonLight;
                        if (babylonSpotLight.angle !== Math.PI / 2.0) {
                            if (light.spot == null) {
                                light.spot = {};
                            }
                            light.spot.outerConeAngle = babylonSpotLight.angle / 2.0;
                        }
                        if (babylonSpotLight.innerAngle !== 0) {
                            if (light.spot == null) {
                                light.spot = {};
                            }
                            light.spot.innerConeAngle = babylonSpotLight.innerAngle / 2.0;
                        }
                    }
                    if (_this._lights == null) {
                        _this._lights = {
                            lights: []
                        };
                    }
                    _this._lights.lights.push(light);
                    if (node.extensions == null) {
                        node.extensions = {};
                    }
                    var lightReference = {
                        light: _this._lights.lights.length - 1
                    };
                    node.extensions[NAME] = lightReference;
                }
            }
            resolve(node);
        });
    };
    return KHR_lights_punctual;
}());
export { KHR_lights_punctual };
_Exporter.RegisterExtension(NAME, function (exporter) { return new KHR_lights_punctual(exporter); });
//# sourceMappingURL=KHR_lights_punctual.js.map